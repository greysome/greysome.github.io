
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="/style.css"/>

<!-- Syntax highlighting -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>

<!-- MathJAX -->
<script>
  MathJax = {
    loader: {
	load: ['[custom]/xypic.js'],
	paths: {custom: 'https://cdn.jsdelivr.net/gh/sonoisa/XyJax-v3@3.0.1/build/'}
    },
    tex: {
	packages: {'[+]': ['xypic']},
	tags: 'ams',
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        macros: {
            A: '\\mathbb{A}', B: '\\mathbb{B}', C: '\\mathbb{C}', D: '\\mathbb{D}',
            E: '\\mathbb{E}', F: '\\mathbb{F}', G: '\\mathbb{G}', H: '\\mathbb{H}',
            I: '\\mathbb{I}', J: '\\mathbb{J}', K: '\\mathbb{K}', L: '\\mathbb{L}',
            M: '\\mathbb{M}', N: '\\mathbb{N}', O: '\\mathbb{O}', P: '\\mathbb{P}',
            Q: '\\mathbb{Q}', R: '\\mathbb{R}', S: '\\mathbb{S}', T: '\\mathbb{T}',
            U: '\\mathbb{U}', V: '\\mathbb{V}', W: '\\mathbb{W}', X: '\\mathbb{X}',
            Y: '\\mathbb{Y}', Z: '\\mathbb{Z}', RP: '\\mathbb{RP}', CP: '\\mathbb{CP}',

	    cA: '\\mathcal{A}', cB: '\\mathcal{B}', cC: '\\mathcal{C}', cD: '\\mathcal{D}',
            cE: '\\mathcal{E}', cF: '\\mathcal{F}', cG: '\\mathcal{G}', cH: '\\mathcal{H}',
            cI: '\\mathcal{I}', cJ: '\\mathcal{J}', cK: '\\mathcal{K}', cL: '\\mathcal{L}',
            cM: '\\mathcal{M}', cN: '\\mathcal{N}', cO: '\\mathcal{O}', cP: '\\mathcal{P}',
            cQ: '\\mathcal{Q}', cR: '\\mathcal{R}', cS: '\\mathcal{S}', cT: '\\mathcal{T}',
            cU: '\\mathcal{U}', cV: '\\mathcal{V}', cW: '\\mathcal{W}', cX: '\\mathcal{X}',
            cY: '\\mathcal{Y}', cZ: '\\mathcal{Z}',

	    fa: '\\mathfrak{a}', fb: '\\mathfrak{b}', fp: '\\mathfrak{p}', fm: '\\mathfrak{m}',
	    fM: '\\mathfrak{M}',

            bf: ['\\mathbf{#1}', 1],
	    x: '\\mathbf{x}', y: '\\mathbf{y}', w: '\\mathbf{w}', Bb: '\\mathbf{b}',
	    i: '\\imath', j: '\\jmath', v: '\\mathbf{v}', w: '\\mathbf{w}',

	    a: '\\alpha', b: '\\beta', g: '\\gamma', e: '\\epsilon', l: '\\lambda',

	    id: '\\mathop{\\rm id}', span: '\\mathop{\\rm span}', im: '\\mathop{\\rm im}', sgn: '\\mathop{\\rm sgn}',
	    End: '\\mathop{\\rm End}', Gal: '\\mathop{\\rm Gal}', Hom: '\\mathop{\\rm Hom}', Inn: '\\mathop{\\rm Inn}',
	    Out: '\\mathop{\\rm Out}', spec: '\\mathop{\\rm Spec}', colim: '\\mathop{\\rm colim}', Ob: '\\mathop{\\rm Ob}',
	    Cn: '\\mathop{\\rm Cn}', Th: '\\mathop{\\rm Th}', Spec: '\\mathop{\\rm Spec}', halo: '\\mathop{\\rm halo}',
	    st: '\\mathop{\\rm st}', inte: '\\mathop{\\rm int}', trdeg: '\\mathop{\\rm tr.deg}', rank: '\\mathop{\\rm rank}',
	    nullity: '\\mathop{\\rm nullity}', Aut: '\\mathop{\\rm Aut}', ann: '\\mathop{\\rm ann}', max: '\\mathop{\\rm max}',
	    min: '\\mathop{\\rm min}', Re: '\\mathop{\\rm Re}', Im: '\\mathop{\\rm Im}', char: '\\mathop{\\rm char}',

	    Set: '\\mathbf{Set}', Top: '\\mathbf{Top}', HTop: '\\mathbf{HTop}', Grp: '\\mathbf{Grp}', Ab: '\\mathbf{Ab}',
	    and: '\\quad\\text{and}\\quad', or: '\\quad\\text{or}\\quad',

	    nin: '\\not\\in', s: '\\subset', seq: '\\subseteq', ss: '\\supset', Seq: '\\supseteq',
	    inv: '{}^{-1}',
	    ol: '\\overline',
	    qed: '\\blacksquare',
	    hR: '{}^*\\R',
	    normal: '\\triangleleft', Normal: '\\triangleright',
	    normaleq: '\\trianglelefteq', Normaleq: '\\trianglerighteq',
	    dlim: '\\varinjlim',
	    invlim: '\\varprojlim',
	    imp: '\\Rightarrow',
	    impd: '\\Leftarrow',
	    eq: ['\\begin{equation}#1\\end{equation}', 1],
	    ZZ: ['\\Z/{#1}\\Z', 1],
	    ZZs: ['(\\Z/{#1}\\Z)^*', 1],
	    legendre: ['\\left(\\frac{#1}{#2}\\right)', 2],
	    d: '\\mathop{}\\!\\mathrm{d}',
	    p: '\\partial',
	    pp: ['{\\p #1\\over\\p #2}', 2],
	    ppp: ['{\\p^2 #1\\over\\p #2\\p #3}', 3],
	    angles: ['\\langle{#1}\\rangle', 1],
	    norm: ['\\left\\Vert{#1}\\right\\Vert', 1],
	    floor: ['\\left\\lfloor{#1}\\right\\rfloor', 1],
	    ceil: ['\\left\\lceil{#1}\\right\\rceil', 1],
        },
    },
    chtml: {
	scale: 0.85,
	linebreaks: {
	    automatic: true
	}
    }
};
</script>

<script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

  </head>

  <body>
    <a href="/index.html">&lt; Back</a> 

    <h1 id="crypto-solutions-for-hackbash-2024">Crypto solutions for Hackbash 2024</h1>
<h3 id="mahjong-cipher">Mahjong Cipher</h3>
<p>A pictoral substitution cipher followed by another substitution cipher.</p>
<h3 id="my-first-encryption">My First Encryption</h3>
<p>Let $h(X)$ denote the SHA1 hash of the character $X$. Given the flag <strong>flag{??$\ldots$??}</strong>, the code computes the hash of each character and stores it in a list $L$, setting the key to be the first 4 elements $(h(\text{f})\ h(\text{l})\ h(\text{a})\ h(\text{g}))$. Then there is a loop where each element of $L$ is replaced by its XOR with every element of the key. Represented pictorially:</p>
<p>$$\begin{matrix}
L &amp; = &amp; h(\text{f}) &amp; h(\text l) &amp; h(\text a) &amp; h(\text g) &amp; h(\text \{) &amp; h(\text?) &amp; h(\text?) &amp; \ldots \\[5pt]
&amp;   &amp;      &amp;      &amp;      &amp; \Big\downarrow \\[5pt]
C &amp; = &amp; h(\text{f})\oplus S &amp; h(\text l)\oplus S &amp; h(\text a)\oplus S &amp; h(\text g)\oplus S &amp; h(\text\{)\oplus S &amp; h(\text ?)\oplus S &amp; h(\text ?)\oplus S &amp; \ldots
\end{matrix}$$</p>
<p>where $S=h(\text f)\oplus h(\text l)\oplus h(\text a)\oplus h(\text g)$. We are given $C$, so the solution is rather straightforward:</p>
<ol>
<li>Compute a table of $h(X)\oplus S$ for all possible characters $X$ (at most 256 of them)</li>
<li>For each character $h(\text ?)\oplus S$ in $C$, match it against the table to find $\text ?$.</li>
</ol>
<h3 id="anti-fermat">Anti-Fermat</h3>
<p>An RSA decryption challenge.</p>
<ol>
<li>
<p>The prime generation algorithm makes use of Dirichlet's theorem on primes in arithmetic progression, thus we know the primes have the form $p$ and $q=p+kd$, where $d$ is known and $k&gt;0$ is likely small.</p>
</li>
<li>
<p>I found both primes by setting up a quadratic $x(x+kd)=x^2+xkd=n$ (where $n=pq$), and then incrementing $k$ until the discriminant is a perfect square, indicating that the solution $x$ is very likely integral (and hopefully a prime, which it did turn out to be).</p>
</li>
<li>
<p>Usually decryption would proceed trivially by finding some inverse $d=e\inv$ mod $(p-1)(q-1)$ and then computing $c^d$ mod $n$, where $c$ is the encrypted message. But this is not possible because of the sly choice of exponent $e=22$, causing $e$ and $(p-1)(q-1)$ to have gcd $&gt;1$.</p>
</li>
<li>
<p>It turns out that 11 is invertible mod $(p-1)(q-1)$ though. So the next best thing is to compute its inverse $d'$, and note that</p>
<p>$$c^{d'}\equiv m^{22d'}\equiv (m^{11d'})^2\equiv m^2 \mod{n}.$$</p>
<p>So the problem reduces to finding $m$ given $m^2$ mod $n$, i.e. finding a modular square root. (Because $m^2\gg n$, simply square rooting doesn't work!) Searching up online, I saw it can be done by some math magic involving Tonelli-Shanks algorithm and CRT which I don't yet fully understand, but I copy-pasted an implementation and ran it, yielding the message with the flag inside!</p>
<p>(Remark: there are many possible modular square roots $r$ mod $n$ which would solve the equation</p>
<p>$$(r-m)(r+m)\equiv 0 \mod{n}.$$</p>
<p>Thus there are technically many possibilities for $m$ given a computed modular square root $r'$: for instance we could have (1) $r'-m=cp$ and $r'+m=dq$ for some $c,d$, or (2) $r'-m=cq$ and $r'+m=dp$ for some $c,d$, or (3) $r'-m\equiv 0$ mod $n$ or (4) $r'+m\equiv0$ mod $n$. Fortunately the solution turned out to fall under either case 3 or 4, I don't remember exactly which.)</p>
</li>
</ol>
<h3 id="xor-key">XOR key</h3>
<p>We are given a 10000-byte long ciphertext $C_1\ldots C_{10000}$, which was encrypted by XORing a random byte sequence $B_1\ldots B_{10000}$ containing the flag with a 30-byte key $K_1\ldots K_{30}$ repeated cyclically. (Note the $B$'s and $K$'s are unknown.) So for instance, $C_1=B_1\oplus K_1$, $C_2=B_2\oplus K_2$ and $C_{31}=B_{31}\oplus K_1$. Rearranging, we get 10000 equations of the form</p>
<p>$$K_{k\ \text{mod}\ 30} = B_k\oplus C_k.$$</p>
<p>Now, we use the fact that each $B_k$ is within a small range of printable characters (let's say there are $n$ of them). Thus in the above equation, $K_{k\ \text{mod}\ 30}$ is actually narrowed down to $n$ possibilities. Then, we use the fact that each $K_i$ appears in at least $\floor{10000/30}=333$ equations; taking all of them into consideration at once, we see that the set of possiblities for $K_i$ is the intersection of 333 $n$-element sets. Computing the intersection for each byte of the key, we happily find that all of them have exactly one element, meaning the key is determined exactly. The flag is then obtained by XORing the ciphertext with the key repeated (since XOR is symmetric).</p>
<h3 id="bleichenbacher-s-attack">Bleichenbacher's attack</h3>
<p>I'm just going to re-explain Jules' write-up in my own words. Recall the set of valid RSA decrypts is a range of integers $[0,n)$, because we are exponentiating the ciphered message $c$, and then taking <em>mod $n$</em>. The set of decrypts with <em>valid padding</em> (which I'll just call valid) is a subrange $[0,k)$ where $0&lt;k&lt;n$---in this case these correspond to the messages starting with a zero byte. We are also given an oracle that takes in any integer $x$, and tells us if $mx$ mod $n$ is valid (this is done by sending the encrypted message $cx^e$ mod $n$, which is decrypted to $(cx^e)^d\equiv mx$ mod $n$).</p>
<p>Now suppose $m&lt;n$. If $x&gt;0$ is the smallest integer such that $mx$ mod $n$ is invalid and $m(x+1)$ mod $n$ is valid, then we can pretty easily conclude that $mx&lt;n\le m(x+1)$, therefore $t=n/m$ lies in $(x,x+1]$. Thus we have determined the integral part of $t$, and we shall find its decimal part via binary search.</p>
<p>Doubling the inequality we have $m(2x)&lt;2n\le m(2x+2)$, and we can split into two cases $m(2x)&lt;2n\le m(2x+1)$ and $m(2x+1)&lt;2n\le m(2x+2)$, which can be rewritten as</p>
<p>$$t\in(x,x+1/2] \quad\text{or}\quad t\in(x+1/2,x+1].$$</p>
<p>(Remark: I believe we need to assume that $m$ is small enough relative to $n$, so that $m(2x)$ mod $n$ doesn't veer off too far left into valid territory, and $m(2x+1)$ mod $n$ right into invalid territory.) We can find out which case it is by checking which of the two conditions holds true:</p>
<ol>
<li>$m(2x)$ invalid, $m(2x+1)$ valid</li>
<li>$m(2x+1)$ invalid, $m(2x+2)$ valid</li>
</ol>
<p>Assuming it is the first case, we can determine whether $t\in(x,x+1/4]$ or $(x+1/4,x+1/2]$ by checking which one of the conditions is valid:</p>
<ol>
<li>$m(4x)$ invalid, $m(4x+1)$ valid</li>
<li>$m(4x+1)$ invalid, $m(4x+2)$ valid</li>
</ol>
<p>In the second case, we instead find out whether $t\in(x+1/2,x+3/4]$ or $(x+3/4,x+1]$ by the conditions</p>
<ol>
<li>$m(4x+2)$ invalid, $m(4x+3)$ valid</li>
<li>$m(4x+3)$ invalid, $m(4x+4)$ valid</li>
</ol>
<p>Then we keep performing the binary search until $t$ is sufficiently precise that $m$ can be recovered by rounding off $n/t$. Some remarks about the practical implementation:</p>
<ol>
<li>Many iterations of the binary search are required. Thus one should use pwntools to script the interaction with the oracle. (Also debugging on a local version is always helpful!)</li>
<li>Don't use standard floats to represent the current approximation to $t$, it does not afford enough precision. And we absolutely need the precision because the flag occurs among the least significant digits of $m$. I used gmpy2 multi-precision floats (with precision 10000) and it worked fine.</li>
</ol>
<h3 id="easier-padding-oracle">Easier Padding Oracle</h3>
<p>This is straightforward once one understands the theory behind AES-CBC padding oracle. Recall the following equation governing AES-CBC decryption:</p>
<p>$$T_{i+16} = C_i\oplus f(C_{i+16}),$$</p>
<p>where $C$ and $T$ are ciphertext and plaintext respectively, $f$ is the block cipher encryption, and 16 is the block size. If we change $C_i$ to $C_i'$ such that the plaintext $T'$ has valid padding, then most likely $T_{i+16}'=(17-i)\ \text{mod}\ 16$. For instance, if setting $C_{14}$ to $C_{14}'$ gives valid padding, then most likely the block containing $T_{30}'$ has the form</p>
<p>$$\underbrace{?????????????}_{13\ \text{bytes}}\ \text{0x03}\ \text{0x03}\ \text{0x03},$$</p>
<p>thus $T_{30}'=3$. We have the equation</p>
<p>$$T_{i+16}' = C_i'\oplus f(C_{i+16}) \implies f(C_{i+16}) = T_{i+16}'\oplus C_i' = \bigl((17-i)\ \text{mod}\ 16\bigr) \oplus C_i',$$</p>
<p>and subbing it into the previous equation allows us to recover $T_{i+16}$:</p>
<p>$$T_{i+16} = C_i\oplus C_i'\oplus \bigl((17-i)\ \text{mod}\ 16\bigr).$$</p>
<p>The flag is obtained simply by applying this formula to each line of the attached text file.</p>
<h3 id="aes-cbc">AES-CBC</h3>
<p>Didn't solve this lol</p>
<div class="footnote">
</div>

  </body>
</html>
